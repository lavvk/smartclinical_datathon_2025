# -*- coding: utf-8 -*-
"""DatathonHealthRisk2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10MaMb7nS3brlxyjoNN1fzZSTYERPJIJG
"""

#!pip install

import numpy
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import joblib

def load_data(path = "Health_Risk_Dataset.csv"):
  df = pd.read_csv(path)
  X = df.drop(columns = ["Risk_Level", "Patient_ID"])
  y = df["Risk_Level"]
  return X, y

def build_pipeline():
  numeric_features = ["Respiratory_Rate", "Oxygen_Saturation", "O2_Scale", "Systolic_BP", "Heart_Rate", "Temperature", "On_Oxygen"]
  categories = ["Consciousness"]
  preprocessor = ColumnTransformer(
  transformers= [("cat", OneHotEncoder(handle_unknown="ignore"), categories), ("num", "passthrough", numeric_features),])
  model = RandomForestClassifier(n_estimators=200, max_depth = 8, class_weight = "balanced", random_state = 42)
  clf = Pipeline(steps=[("preprocess", preprocessor), ("model", model)])
  return clf

def train_model():
  X, y = load_data()
  clf = build_pipeline()
  X_train, X_val, y_train, y_val = train_test_split(X, y, test_size = 0.2, stratify = y, random_state = 42)
  clf.fit(X_train, y_train)
  preds = clf.predict(X_val)
  print(classification_report(y_val, preds))
  joblib.dump(clf, "risk_model.joblib")
  return clf

def predict_patient(vitals_dict, model_path = "risk_model.joblib"):
  model = joblib.load(model_path)
  df = pd.DataFrame([vitals_dict])
  prediction = model.predict(df)[0]
  proba = model.predict_proba(df)[0]
  return prediction, {label: round(prob, 3) for label, prob in zip(model.classes_, proba)}

if __name__ == "__main__":
  train_model()
  example = {"Respiratory_Rate": 29,
        "Oxygen_Saturation": 91,
        "O2_Scale": 1,
        "Systolic_BP": 79,
        "Heart_Rate": 135,
        "Temperature": 38.4,
        "On_Oxygen": 0,
        "Consciousness": "A"}
  pred, prob = predict_patient(example)
  print(pred)
  print(prob)

import random
import csv
import math
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
import pprint

RANDOM_SEED = 42
random.seed(RANDOM_SEED)

@dataclass
class Patient:
    patient_id: str
    respiratory_rate: float
    oxygen_saturation: float
    o2_scale: int
    systolic_bp: float
    heart_rate: float
    temperature: float
    consciousness: str
    on_oxygen: int
    risk_level: str

    deterioration_prob: float = 0.0
    predicted_label: Optional[str] = None
    predicted_probs: Dict[str, float] = field(default_factory=dict)
    received_oxygen: bool = False
    received_nurse: bool = False
    received_monitor: bool = False
    history: List[Dict[str, Any]] = field(default_factory=list)

    def to_model_dict(self) -> Dict[str, Any]:
        return {
            "Respiratory_Rate": self.respiratory_rate,
            "Oxygen_Saturation": self.oxygen_saturation,
            "O2_Scale": self.o2_scale,
            "Systolic_BP": self.systolic_bp,
            "Heart_Rate": self.heart_rate,
            "Temperature": self.temperature,
            "On_Oxygen": self.on_oxygen,
            "Consciousness": self.consciousness,
        }

    def snapshot(self) -> Dict[str, Any]:
        return {
            "patient_id": self.patient_id,
            "rr": round(self.respiratory_rate, 2),
            "o2": round(self.oxygen_saturation, 2),
            "o2_scale": self.o2_scale,
            "bp": round(self.systolic_bp, 1),
            "hr": round(self.heart_rate, 1),
            "temp": round(self.temperature, 2),
            "conc": self.consciousness,
            "on_oxygen": self.on_oxygen,
            "pred_label": self.predicted_label,
            "pred_prob": self.predicted_probs.copy(),
            "received_oxygen": self.received_oxygen,
            "received_nurse": self.received_nurse,
            "received_monitor": self.received_monitor,
        }

def load_patients_from_csv(path: str, n: Optional[int] = None) -> List[Patient]:
    patients = []
    with open(path, newline='') as csvfile:
        reader = csv.DictReader(csvfile, delimiter=',' )
        for i, row in enumerate(reader):
            if n is not None and i >= n:
                break
            p = Patient(
                patient_id=row.get('Patient_ID', f'P{i}'),
                respiratory_rate=float(row.get('Respiratory_Rate', 0) or 0),
                oxygen_saturation=float(row.get('Oxygen_Saturation', 0) or 0),
                o2_scale=int(row.get('O2_Scale', 1) or 1),
                systolic_bp=float(row.get('Systolic_BP', 0) or 0),
                heart_rate=float(row.get('Heart_Rate', 0) or 0),
                temperature=float(row.get('Temperature', 37) or 37),
                consciousness=row.get('Consciousness', 'A') or 'A',
                on_oxygen=int(row.get('On_Oxygen', 0) or 0),
                risk_level=row.get('Risk_Level', 'Low') or 'Low'
            )
            patients.append(p)
    return patients

def fcfs_allocate(patients: List[Patient], resources: Dict[str, int]) -> Dict[str, List[Patient]]:
    pool = sorted(patients, key=lambda p: p.patient_id)
    allocation = {'oxygen': [], 'nurse': [], 'monitor': []}
    allocation['oxygen'] = pool[:resources['oxygen_units']]
    allocation['nurse'] = pool[:resources['nurse_capacity']]
    allocation['monitor'] = pool[:resources['monitors']]
    return allocation

def highest_risk_allocate(patients: List[Patient], resources: Dict[str, int]) -> Dict[str, List[Patient]]:
    pool = sorted(patients, key=lambda p: p.deterioration_prob, reverse=True)
    return {
        'oxygen': pool[:resources['oxygen_units']],
        'nurse': pool[:resources['nurse_capacity']],
        'monitor': pool[:resources['monitors']]
    }

def oxygen_priority_allocate(patients: List[Patient], resources: Dict[str, int]) -> Dict[str, List[Patient]]:
    low_o2 = sorted(patients, key=lambda p: p.oxygen_saturation)
    high_prob = sorted(patients, key=lambda p: p.deterioration_prob, reverse=True)
    return {
        'oxygen': low_o2[:resources['oxygen_units']],
        'nurse': high_prob[:resources['nurse_capacity']],
        'monitor': high_prob[:resources['monitors']]
    }

def fairness_allocate(patients: List[Patient], resources: Dict[str, int]) -> Dict[str, List[Patient]]:
    def cluster(p):
        if p.oxygen_saturation < 94 or p.respiratory_rate > 22:
            return 'resp'
        if p.systolic_bp < 100 or p.heart_rate > 120:
            return 'circ'
        if p.temperature > 38:
            return 'inf'
        return 'other'
    clusters = {'resp': [], 'circ': [], 'inf': [], 'other': []}
    for p in patients:
        clusters[cluster(p)].append(p)
    main = ['resp', 'circ', 'inf']
    def split(n):
        base = n // 3
        rem = n % 3
        return [base + (1 if i < rem else 0) for i in range(3)]
    ox_q = split(resources['oxygen_units'])
    nu_q = split(resources['nurse_capacity'])
    mo_q = split(resources['monitors'])
    allocation = {'oxygen': [], 'nurse': [], 'monitor': []}
    for i, cl in enumerate(main):
        pool = sorted(clusters[cl], key=lambda p: p.deterioration_prob, reverse=True)
        allocation['oxygen'].extend(pool[:ox_q[i]])
        allocation['nurse'].extend(pool[:nu_q[i]])
        allocation['monitor'].extend(pool[:mo_q[i]])
    return allocation

def greedy_allocate(patients: List[Patient], resources: Dict[str, int]) -> Dict[str, List[Patient]]:
    oxy_score = sorted(patients, key=lambda p: p.deterioration_prob * (100 - p.oxygen_saturation), reverse=True)
    nurse_score = sorted(patients, key=lambda p: p.deterioration_prob, reverse=True)
    def monitor_score(p):
        return p.deterioration_prob * (1 - abs(0.5 - p.deterioration_prob))
    monitor_sorted = sorted(patients, key=monitor_score, reverse=True)
    return {
        'oxygen': oxy_score[:resources['oxygen_units']],
        'nurse': nurse_score[:resources['nurse_capacity']],
        'monitor': monitor_sorted[:resources['monitors']]
    }

POLICIES = {
    'fcfs': fcfs_allocate,
    'highest_risk': highest_risk_allocate,
    'oxygen_priority': oxygen_priority_allocate,
    'fairness': fairness_allocate,
    'greedy': greedy_allocate
}

def apply_allocation(allocation: Dict[str, List[Patient]]):
    for p in allocation.get('oxygen', []):
        p.received_oxygen = True
    for p in allocation.get('nurse', []):
        p.received_nurse = True
    for p in allocation.get('monitor', []):
        p.received_monitor = True

def reset_received_flags(patients: List[Patient]):
    for p in patients:
        p.received_oxygen = False
        p.received_nurse = False
        p.received_monitor = False

def recompute_predictions(patients: List[Patient]):
    for p in patients:
        pred_label, prob_dict = predict_patient(p.to_model_dict())
        p.predicted_label = pred_label
        p.predicted_probs = prob_dict
        p.deterioration_prob = prob_dict.get('High', 0.0) if 'High' in prob_dict else max(prob_dict.values())

def update_vitals(patients: List[Patient]):
    for p in patients:
        if not p.received_nurse:
            p.respiratory_rate += random.uniform(0, 1.5)
            p.heart_rate += random.uniform(0, 3.0)
            p.systolic_bp -= random.uniform(0, 1.2)
        else:
            p.respiratory_rate = max(8, p.respiratory_rate - random.uniform(0, 1.0))
            p.heart_rate = max(40, p.heart_rate - random.uniform(0, 3.0))
            p.systolic_bp = min(200, p.systolic_bp + random.uniform(0, 1.5))
        if p.received_oxygen:
            p.oxygen_saturation = min(100, p.oxygen_saturation + random.uniform(0.5, 2.0))
            p.on_oxygen = 1
        else:
            p.oxygen_saturation = max(60, p.oxygen_saturation - random.uniform(0, 1.5))
            p.on_oxygen = 0
        p.history.append(p.snapshot())

def summarize(patients: List[Patient]) -> Dict[str, Any]:
    crit = sum(1 for p in patients if p.predicted_label == 'High' or p.deterioration_prob > 0.8)
    avg_prob = sum(p.deterioration_prob for p in patients) / len(patients) if patients else 0
    treated_ox = sum(1 for p in patients if p.received_oxygen)
    treated_nurse = sum(1 for p in patients if p.received_nurse)
    treated_monitor = sum(1 for p in patients if p.received_monitor)
    return {
        'critical_count': crit,
        'avg_prob': round(avg_prob, 3),
        'treated_oxygen': treated_ox,
        'treated_nurse': treated_nurse,
        'treated_monitor': treated_monitor
    }

class Simulator:
    def __init__(self, patients: List[Patient], config: Dict[str, int], policy_name: str):
        self.patients = patients
        self.config = config
        self.policy_name = policy_name
        self.policy_func = POLICIES.get(policy_name)
        self.time = 0
        self.logs = []

    def initialize(self):
        recompute_predictions(self.patients)
        for p in self.patients:
            p.history = [p.snapshot()]

    def step(self):
        reset_received_flags(self.patients)
        recompute_predictions(self.patients)
        allocation = self.policy_func(self.patients, self.config)
        apply_allocation(allocation)
        update_vitals(self.patients)
        stats = summarize(self.patients)
        self.logs.append({'time': self.time, 'allocation': {k: [x.patient_id for x in v] for k, v in allocation.items()}, 'stats': stats})
        self.time += 1

    def run(self, steps: int = 24):
        self.initialize()
        for _ in range(steps):
            self.step()
        return self.logs

def demo_synthetic(batch_size: int = 20):
    patients = []
    for i in range(batch_size):
        p = Patient(
            patient_id=f'SYN{i}',
            respiratory_rate=random.uniform(12, 30),
            oxygen_saturation=random.uniform(85, 99),
            o2_scale=random.choice([1,2,3]),
            systolic_bp=random.uniform(80,140),
            heart_rate=random.uniform(60,160),
            temperature=random.uniform(36.5,39.5),
            consciousness=random.choice(['A','P','U']),
            on_oxygen=random.choice([0,1]),
            risk_level=random.choice(['Low','Medium','High'])
        )
        patients.append(p)
    cfg = {'oxygen_units': 6, 'nurse_capacity': 3, 'monitors': 4}
    sim = Simulator(patients, cfg, policy_name='highest_risk')
    logs = sim.run(steps=6)
    pprint.pprint(logs[-1])
    return sim, logs

if __name__ == '__main__':
    try:
        patients = load_patients_from_csv('Health_Risk_Dataset.csv', n=20)
        cfg = {'oxygen_units': 6, 'nurse_capacity': 3, 'monitors': 4}
        sim = Simulator(patients, cfg, policy_name='greedy')
        logs = sim.run(steps=6)
        print('Last log:')
        pprint.pprint(logs[-1])
    except FileNotFoundError:
        print('CSV not found, running synthetic demo')
        demo_synthetic()